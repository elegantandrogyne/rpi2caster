{"name":"rpi2caster","tagline":"Raspberry Pi controls a Monotype composition caster.","body":"rpi2caster\r\n==========\r\nRaspberry Pi controls a Monotype composition caster, which is a machine designed in late 19th century for casting composed type according to a \"program\" written on a perforated paper tape. These casters are still used by printshops using traditional lead type & press technology.\r\n\r\nI've chosen Raspberry Pi Mod. B (for future devices it'll be replaced by B+, a redesigned PCB which is a bit nicer to build into projects). The Raspberry has to be connected via GPIO with the following peripherals:\r\n\r\n1. 32 solenoid valves controlling the air flowing into one or more of 31 composition caster's air tubes\r\n2. Machine cycle sensor, which determines when the air flows (originally, an air manifold was pressed against paper tape and air flowed through holes into the tubes)\r\n\r\nOptionally, the Raspberry can be connected to:\r\n1. Shutdown button for shutting the Raspberry down without entering any commands\r\n2. Power LED lighting up when the machine is ready\r\n3. Valve indicator LEDs showing the valves/airlines which are currently on\r\n4. Temperature sensor(s) for cooling water, lead etc. temperatures\r\n5. Motor on, motor off relays (you can do that to turn the machine on/off automatically... but you'd need to modify the caster's wiring)\r\n6. Clutch trigger solenoid - this can be done as well\r\n\r\nThe program logic will be based on computer2caster by John Cornelisse\r\nOriginal idea described at http://letterpress.ch\r\n\r\nContrary to computer2caster, this program features:\r\n\r\n1. getting rid of all obsolete hardware and software [M$ DOS and LPT / RS232 ports] as well as hardware/software limitation workarounds, mostly relating to the M$ QuickC2 compiler used for building computer2caster\r\n2. self-contained, embedded system which can be controlled with local KVM (HDMI/composite video for display, USB for keyboard & mouse) as well as SSH or VNC over the network\r\n3. using MySQL for storing all data relating to matrices and matrix cases, instead of hardcoding the layout data (thus enabling data management with e.g. LibreOffice Base or web apps)\r\n4. native support for UTF-8 - no codepages and so on!\r\n5. possible developments in the future: web app front-end, reading typesetting from formatted input files [PDF, ODS, DOC, LaTeX...] etc.\r\n\r\n\r\nHardware\r\n========\r\n1. Get a Raspberry Pi mod B or B+ and install Raspbian\r\n2. Make a pneumatic interface that attaches on the Monotype's paper tower - or have it made by someone with a CNC mill. \r\n\tThis is the hardest part. The pneumatic interface must be very precisely done, so that holes are aligned with those on the paper tower and no air leaks.\r\n3. Get 31 three-way (3/2) solenoid valves on valve islands. 12 or 24V DC. \r\n\tIMPORTANT: Some valves require minimum air pressure of 2...2.5bar. Since the Monotype uses only 1bar, \r\n\tthe pressure differential across the valve will be too low and the valve won't open. We need the 0bar minimum \r\n\tpressure variety, even though they may take more electrical power to open.\r\n\tJohn Cornelisse used the MATRIX (Italy) BX758 series. The valve block is very compact. It features 8 valves in \r\n\ta 55x55mm enclosure, with 12V DC or 24V DC controls and minimal pressure of 0 bar.\r\n4. Make a RPi I2C I/O extension as shown at:\r\n\thttp://www.abelectronics.co.uk/products/3/Raspberry-Pi/18/IO-Pi-32-Channel-Port-Expander-for-the-Raspberry-Pi-computer-boards\r\n\tI built a module using a THT prototyping board and DIP IC's. You also need FET or bipolar\r\n\tdrivers to connect the MCP23017 outputs with each of the solenoid valves. Four ULN2803 ICs (8-channel Darlington drivers \r\n\twith surge suppressing diodes) are perfect for this. Each MCP23017 uses one ULN2803 for port A and one for port B.\r\n\tYou have to choose different I2C bus addresses for both MCP23017. This is achieved by connecting different combinations of A0, A1\r\n\tand A2 input (pin numbers 15, 16, 17) to +3V3 or GND. For my device, I've chosen 0x20 (all pins grounded) for the chip that \r\n\tcontrols rows, and 1x20 (3V3 on pin 15 and pins 16, 17 grounded) for the chip that controls columns.\r\n5. A power supply capable of 5V 1A (regulated) and 24V 2...5A. I used a nice SMPS salvaged from a fax machine.\r\n\r\n\r\nSystem\r\n======\r\nYou need to install some software to use the RPi GPIO for controlling the interface.\r\n\r\nRaspbian jessie or later. It may work on wheezy, but I'm not sure.\r\n\tInitial setup (Squeeze won't work because SSH is disabled by default; you have to set up with a local console!):\r\n        Install an utility called nmap and scan your network to find the running hosts by typing \"nmap -sP {subnet IP address}\". For example, \"nmap -sP 192.168.1.0/24\" if your IP address is 192.168.1.x.\r\n\tConnect the Raspberry to your LAN and power. It should get its IP address by DHCP. Try to scan the network by running \r\n        \"nmap -sP {subnet IP address}\" again; you should see one more IP address and that's probably your RPi.\r\n        SSH into it (username: pi, password: raspberry). Since it's your first logon, raspi-config will start automatically. \r\n        Expand rootfs, choose locale, timezone & keyboard layout. You can change the hostname (I've named my machine \"monotype\"), \r\n        set up the password etc. Exit raspi-config when you're done.\r\n\tAs for network setup - I recommend either a static IP, or setting up your router to offer Raspberry a a static DHCP lease based on the MAC address, so that Raspberry's IP address will remain the same. You can also scan the network for hosts \r\n\twith the RPi's MAC address after each boot to determine the IP address. \r\n\tCreate user accounts and disable no-password sudoing for \"pi\" by commenting out the respective line in /etc/sudoers (for security reasons). You may want to  remove \"pi\" from the \"sudo\" and \"adm\" groups as well.\r\n\tAdd new users to groups user \"pi\" belongs to, and also the \"gpio\" and \"i2c\" groups. \r\n        Since you'll log on the machine via SSH, you can use a RSA key authentication instead of entering a password on each logon.\r\n        Create a ~/.ssh/authorized_keys file and paste your account@machine's id_rsa.pub contents there. Then you can just ssh by typing\r\n        \"ssh username@ip\" or \"ssh username@hostname\" if you have a local DNS server on your network. \r\n        You may want to change sysvinit to systemd (for Jessie), bash to zsh etc. if you want to, know what you're doing \r\n\tand don't have anything against fiddling with your config files.\r\n\tYou can enable GUI access by VNC if you want to use a graphical interface. Install tightvncserver. Edit /etc/lightdm/lightdm.conf and uncomment the lines in VNC section. \r\n\tChange the port, geometry etc. if you wish. You don't have to create any init scripts; lightdm will already take care of running the\r\n\tVNC server. Just run \"vncviewer [hostname or IP addr]:[port]\" client-side and you'll get a lightdm login screen. Sign in to your account.\r\n\tIf you want to use the pins 8 and 10 on the P1 header (which are used as UART's RxD and TxD lines by default), you have to disable\r\n\tthe serial port. That is done by editing two files:\r\n\t/etc/inittab: we have to comment out any lines containing the \"ttyAMA0 115200 vt100\" string\r\n\t/boot/cmdline.txt: remove all references to ttyAMA0\r\n\r\nDependencies\r\n============\r\nSome of the dependencies will be marked as \"(repo)\". This means that you can install them from Raspbian repository using apt or aptitude.\r\n1. RPi.GPIO Python library - https://pypi.python.org/packages/source/R/RPi.GPIO\r\n\tMake sure you have python-dev and python3-dev installed (build dependencies). Download, untar and run \"sudo python setup.py install\".\r\n2. libi2c-dev (repo) - I2C device library, which provides the I2C kernel module.\r\n\tInstall with \"sudo aptitude install libi2c-dev\"\r\n\tAfter installing i2c-dev, add user(s) to the i2c group unless you want to run the software as root, which is obviously not recommended. \r\n\tAdd \"i2c-dev\" module to the /etc/modules file so that you won't have to modprobe it each time.\r\n\tRemove (or comment) the i2c-bcm2708 in /etc/modprobe.d/raspi-blacklist.conf\r\n3. wiringPi2 library - find it (with setup instructions) at https://projects.drogon.net/raspberry-pi/wiringpi/download-and-install/\r\n\tThis is required for programs to access GPIO.\r\n4. i2c-tools (repo) - this provides i2cdetect which is used for finding the I2C device address, and i2cset, i2cdump and i2cget, for debugging. libi2c-dev depends on i2c-tools, so this will already be installed in step 2.\r\n5. python-smbus (repo), Python SMBus & I2C library, probably not necessary thanks to wiringpi\r\n6. python-setuptools (repo) - you need it to install a Python module for WiringPi\r\n7. WiringPi2-Python - install it from GitHub. Instructions at https://github.com/WiringPi/WiringPi2-Python/blob/master/README\r\n8. gpio - command line utility for GPIO setup & management, used by powerbuttond.py\r\n\r\n\r\nGarbage removal\r\n===============\r\nThe original Raspbian distro has some unneeded software installed by default. We can get rid of it by using \"sudo aptitude purge...\":\r\n-wolfram-engine - removing it will clean aomewhere around 450MB (!)\r\n-X, LXDE etc. unless you want to VNC into the machine or set up a local console with GUI\r\n-LibreOffice\r\n-anything related to Scratch\r\n\r\nYou may be interested in an unofficial image called \"Raspbian Server Edition\", which is a stripped and lightweight Raspbian without any desktop environments etc.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}