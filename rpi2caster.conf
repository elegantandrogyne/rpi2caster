# Define the casters you'll be using your interface with.
# If you have a keyboard's paper tower, define it here too.
#
# A caster is defined by a sub-section in the "Casters" section.
# The subsection is named with the caster's defined name.
#
# In the caster subsection, you specify parameters:
#
#   interface_id [0, 1, 2, 3] - ID of an interface to use with this caster,
#
#   diecase_system [norm15, norm17, hmn, kmn, shift] - diecase format
#                  and how to access row 16 if applicable:
#                  norm15    - 15x15 matrix cases ONLY (oldest)
#                  norm17    - 15x17 NI,NL columns (newer)
#                  hmn       - 16x17 H-M-N (rare)
#                  kmn       - 16x17 K-M-N (rare)
#                  shift     - 16x17 unit shift (post-60s)
#
#   unit_adding [0, 1] - whether the machine has an unit-adding attachement
#
#   justification [norm, alt] - justification mode on a caster:
#                 norm        - 0005 fine, 0075 coarse
#                 alt         - NJ fine (replaces 0005), NK coarse (replaces 0075)
#
# If you're using the unit adding attachment, justification will be alternate! 
#
# If the subsection has no entries beside interface_id,
# then it's not usable as a caster, but can be used
# for a keyboard's paper tower.


[mkart-cc]
interface_id=0
diecase_system=shift
unit_adding=0
justification=norm

[mkart-lcc1]
diecase_system=norm17
unit_adding=0
interface_id=0
justification=norm

[keyboard]
is_perforator=1
interface_id=0


# Interfaces:
#
# Define 0, one or more interfaces connected to your
# Raspberry Pi. An interface MUST have following parameters:
#   active [0 or 1]          - whether the interface can be used,
#   sensor_gpio [int]        - Broadcom number for sensor GPIO,
#   mcp0_address [hexstring] - 1st MCP23017 I2C address,
#   mcp1_address [hexstring] - 2nd MCP23017 I2C address,
#   pin_base [int]           - pin base for numbering GPIOs
#                                on MCP23017 chips.
#   signals_arrangement [str]- order of Monotype signals assigned to outputs
#                              (must be registered under SignalsArrangements)
#
# If no interface is defined, the program will use
# built-in defaults for interface_id=0.


[Interface0]
active=1
stop_gpio=24
sensor_gpio=17
mcp0_address=0x20
mcp1_address=0x21
pin_base=65
signals_arr=alphanum

[Interface1]
active=0
stop_gpio=6
sensor_gpio=12
mcp0_address=0x22
mcp1_address=0x23
pin_base=98
signals_arr=monotype



[SignalsArrangements]
# You can arrange your signals as you wish and make connections accordingly.
# Just choose one of these arrangements for the "signal_arrangement" option
# in your interface section. You can also define a new one.

# mcp0 is the MCP23017 with lower address (e.g. 0x20), mcp1 - the chip
# with higher address (e.g. 0x21). If you're using DIP or SOIC chips,
# I/O bank A uses physical pin numbers 21...18, bank B is 1...8.
# See datasheet for further info."""

#   "alphanum" arrangement - alphanumerically, numbers first, O+15 last:
#
#    mcp0 bank A | mcp0 bank B                | mcp1 bank A | mcp1 bank B
#    ---------------------------------------------------------------------
#    12345678    | 9 10 11 12 13 14 0005 0075 | ABCDEFGH    | IJKLMN S O15

alphanum=1,2,3,4,5,6,7,8,9,10,11,12,13,14,0005,0075,A,B,C,D,E,F,G,H,I,J,K,L,M,N,S,O15

#   "monotype" arrangement - according to Monotype code order on paper tower:
#
#    mcp0 bank A | mcp0 bank B     | mcp1 bank A | mcp1 bank B
#    -----------------------------------------------------------------------
#    NMLKJIHG    | F S ED 0075 CBA | 12345678    | 9 10 11 12 13 14 0005 O15

monotype=N,M,L,K,J,I,H,G,F,S,E,D,0075,C,B,A,1,2,3,4,5,6,7,8,9,10,11,12,13,14,0005,O15

#    "valves_ud" - grouping odd and even Monotype signals in valve units,
#    where first MCP controls odd signals ("upper" paper tower inputs
#    if you use V air connection block) and second MCP controls even signals:
#
#    mcp0 bank A   | mcp0 bank B      | mcp1 bank A | mcp1 bank B
#    --------------------------------------------------------------------
#    NLJHFE 0075 B | 13579 11 13 0005 | MKIGSDCA    | 2468 10 12 14 O15

valves_ud=N,L,J,H,F,E,0075,B,1,3,5,7,9,11,13,0005,M,K,I,G,S,D,C,A,2,4,6,8,10,12,14,O15

#    "valves_lr" - grouping odd and even Monotype signals in valve units,
#    where first MCP controls left half of signals - N...A,
#    and second MCP controls right half - 1...0005:
#
#    mcp0 bank A   | mcp0 bank B | mcp1 bank A      | mcp1 bank B
#    --------------------------------------------------------------------
#    NLJGFE 0075 B | MKIHSDCA    | 13579 11 13 0005 | 2468 10 12 14 O15

valves_lr=N,L,J,H,F,E,0075,B,M,K,I,G,S,D,C,A,1,3,5,7,9,11,13,0005,2,4,6,8,10,12,14,O15



[Control]
# Control parameters:
#
# Specify GPIO numbers for the controls related to system
# (poweroff button, reboot button, ready LED)
# These parameters will be read by the gpiodaemon program,
# which also sets up the interrupt handling for sensor
# and emergency stop button inputs (these things have to
# be done with root privileges - and rpi2caster is meant
# to run under regular user account).

led_gpio=18
shutdown_gpio=22
reboot_gpio=23



[Database]
# Database parameters:
#
# The type and access path of a database, in which all workshop
# inventory is stored (i.e. wedges, diecases, matrix data).
# Currently, only SQLite3 is supported,
# but there is a possibility of adding local or remote MySQL db
# (especially on Raspi 2 or newer, which has more processing power
# and can run a "heavyweight" MySQL server).
# This would be useful for large printshops using several casters
# with individual interfaces - with a centralized database
# to store all the diecase data etc.

type=sqlite3
path=database/monotype.db
